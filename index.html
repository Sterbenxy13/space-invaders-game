<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: Arial, sans-serif;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            background: linear-gradient(to bottom, #0a0e27, #1a1a2e);
            border: 3px solid #00ff00;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        #gameInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 18px;
            z-index: 100;
            text-shadow: 0 0 10px #00ff00;
        }

        #score, #lives {
            margin-bottom: 10px;
        }

        .player {
            position: absolute;
            bottom: 20px;
            width: 40px;
            height: 40px;
            background: 
                radial-gradient(ellipse 30% 40% at 50% 30%, rgba(0, 255, 255, 0.8) 0%, transparent 70%),
                linear-gradient(to top, #00ff00 0%, #00cc00 40%, #00ffaa 70%, #00ffcc 100%);
            clip-path: polygon(
                50% 0%, 
                55% 15%, 
                65% 30%, 
                100% 85%, 
                85% 100%, 
                70% 90%, 
                50% 95%, 
                30% 90%, 
                15% 100%, 
                0% 85%, 
                35% 30%, 
                45% 15%
            );
            box-shadow: 
                0 0 15px #00ff00,
                0 0 30px rgba(0, 255, 255, 0.5),
                inset 0 0 10px rgba(255, 255, 255, 0.3);
            animation: playerPulse 1.5s ease-in-out infinite, playerHover 0.8s ease-in-out infinite;
        }

        .player::before {
            content: '';
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #00ffff 0%, #00ff00 50%, transparent 70%);
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff, 0 0 20px #00ff00;
            animation: cockpitGlow 0.5s ease-in-out infinite alternate;
        }

        .player::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 10px;
            height: 15px;
            background: linear-gradient(to bottom, #ff6600 0%, #ffff00 50%, transparent 100%);
            clip-path: polygon(30% 0%, 70% 0%, 100% 100%, 0% 100%);
            animation: thrusterFlame 0.1s ease-in-out infinite alternate;
            box-shadow: 0 0 10px #ff6600, 0 0 20px #ffff00;
        }

        @keyframes playerPulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        @keyframes playerHover {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }

        @keyframes cockpitGlow {
            0% { opacity: 0.7; transform: translateX(-50%) scale(0.9); }
            100% { opacity: 1; transform: translateX(-50%) scale(1.1); }
        }

        @keyframes thrusterFlame {
            0% { height: 12px; opacity: 0.8; }
            100% { height: 18px; opacity: 1; }
        }

        /* Base enemy styles */
        .enemy {
            position: absolute;
            width: 40px;
            height: 40px;
            animation: enemyHover 1.2s ease-in-out infinite;
        }

        /* Enemy Type 1: Classic Invader - Red aggressive design */
        .enemy-type-1 {
            background: 
                radial-gradient(ellipse 40% 30% at 50% 60%, rgba(255, 100, 100, 0.8) 0%, transparent 60%),
                linear-gradient(to bottom, #ff0000 0%, #cc0000 40%, #990000 70%, #660000 100%);
            clip-path: polygon(
                20% 0%, 
                30% 20%, 
                40% 10%, 
                50% 25%, 
                60% 10%, 
                70% 20%, 
                80% 0%, 
                90% 30%, 
                100% 50%, 
                85% 100%, 
                15% 100%, 
                0% 50%, 
                10% 30%
            );
            box-shadow: 
                0 0 15px #ff0000,
                0 0 30px rgba(255, 0, 0, 0.5),
                inset 0 0 8px rgba(255, 200, 200, 0.3);
        }

        .enemy-type-1::before {
            content: '';
            position: absolute;
            top: 45%;
            left: 25%;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #ffff00 0%, #ff6600 70%, transparent 100%);
            border-radius: 50%;
            box-shadow: 0 0 5px #ffff00, 18px 0 5px #ffff00;
            animation: enemyEyeGlow 0.8s ease-in-out infinite alternate;
        }

        /* Enemy Type 2: Alien Scout - Purple/Magenta sleek design */
        .enemy-type-2 {
            background: 
                radial-gradient(ellipse 35% 35% at 50% 50%, rgba(200, 100, 255, 0.7) 0%, transparent 60%),
                linear-gradient(135deg, #9900ff 0%, #6600cc 30%, #cc00ff 60%, #9900ff 100%);
            clip-path: polygon(
                50% 0%, 
                65% 15%, 
                100% 35%, 
                90% 50%, 
                100% 65%, 
                80% 100%, 
                20% 100%, 
                0% 65%, 
                10% 50%, 
                0% 35%, 
                35% 15%
            );
            box-shadow: 
                0 0 15px #9900ff,
                0 0 30px rgba(150, 0, 255, 0.5),
                inset 0 0 10px rgba(255, 150, 255, 0.3);
            animation: enemyHover 1s ease-in-out infinite, enemyRotate 3s linear infinite;
        }

        .enemy-type-2::before {
            content: '';
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #00ffff 0%, #9900ff 60%, transparent 100%);
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff, 0 0 20px #9900ff;
            animation: alienCoreGlow 0.6s ease-in-out infinite alternate;
        }

        /* Enemy Type 3: Heavy Fighter - Orange/Yellow armored design */
        .enemy-type-3 {
            background: 
                radial-gradient(ellipse 50% 40% at 50% 40%, rgba(255, 200, 100, 0.6) 0%, transparent 50%),
                linear-gradient(to bottom, #ff9900 0%, #ff6600 30%, #cc4400 60%, #993300 100%);
            clip-path: polygon(
                30% 0%, 
                40% 5%, 
                50% 0%, 
                60% 5%, 
                70% 0%, 
                85% 20%, 
                100% 45%, 
                95% 70%, 
                80% 100%, 
                60% 85%, 
                50% 100%, 
                40% 85%, 
                20% 100%, 
                5% 70%, 
                0% 45%, 
                15% 20%
            );
            box-shadow: 
                0 0 12px #ff9900,
                0 0 25px rgba(255, 150, 0, 0.6),
                inset 0 0 8px rgba(255, 255, 200, 0.4);
        }

        .enemy-type-3::before {
            content: '';
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 6px;
            background: linear-gradient(to bottom, #ff0000 0%, #ffff00 100%);
            border-radius: 2px;
            box-shadow: 0 0 8px #ff6600;
            animation: enemyVisorGlow 0.4s ease-in-out infinite alternate;
        }

        .enemy-type-3::after {
            content: '';
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 4px;
            background: linear-gradient(90deg, transparent 0%, #ff6600 30%, #ffff00 50%, #ff6600 70%, transparent 100%);
            animation: weaponCharge 0.3s ease-in-out infinite alternate;
        }

        @keyframes enemyHover {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(3px) scale(1.02); }
        }

        @keyframes enemyEyeGlow {
            0% { opacity: 0.6; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1.1); }
        }

        @keyframes enemyRotate {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(30deg); }
        }

        @keyframes alienCoreGlow {
            0% { opacity: 0.5; box-shadow: 0 0 5px #00ffff, 0 0 10px #9900ff; }
            100% { opacity: 1; box-shadow: 0 0 15px #00ffff, 0 0 30px #9900ff; }
        }

        @keyframes enemyVisorGlow {
            0% { opacity: 0.7; width: 14px; }
            100% { opacity: 1; width: 18px; }
        }

        @keyframes weaponCharge {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .projectile {
            position: absolute;
            width: 5px;
            height: 15px;
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }

        .obstacle {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #ffaa00;
            border: 2px solid #ffaa00;
            box-shadow: 0 0 5px #ffaa00;
            clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
        }

        #gameOverScreen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #gameOverScreen.show {
            display: flex;
        }

        #gameOverText {
            color: #00ff00;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ff00;
        }

        #finalScore {
            color: #00ff00;
            font-size: 24px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #00ff00;
        }

        #restartBtn {
            padding: 15px 40px;
            font-size: 20px;
            background: #00ff00;
            color: #000;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            transition: all 0.3s;
        }

        #restartBtn:hover {
            background: #00aa00;
            box-shadow: 0 0 20px #00ff00;
        }

        #waveInfo {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff00;
            font-size: 18px;
            z-index: 100;
            text-shadow: 0 0 10px #00ff00;
        }

        #waveTransition {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 150;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #waveTransition.show {
            display: flex;
        }

        #waveTransitionText {
            color: #00ff00;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ff00;
            animation: pulse 1s ease-in-out infinite;
        }

        #waveTransitionSubtext {
            color: #00ff00;
            font-size: 24px;
            text-shadow: 0 0 10px #00ff00;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .boss {
            position: absolute;
            width: 120px;
            height: 80px;
            background: linear-gradient(to bottom, #ff00ff, #8800ff);
            clip-path: polygon(10% 0%, 90% 0%, 100% 30%, 85% 50%, 100% 70%, 90% 100%, 10% 100%, 0% 70%, 15% 50%, 0% 30%);
            border: 3px solid #ff00ff;
            box-shadow: 0 0 20px #ff00ff, 0 0 40px #8800ff;
        }

        .boss-projectile {
            position: absolute;
            width: 8px;
            height: 20px;
            background: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }

        #bossHealthContainer {
            display: none;
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #ff00ff;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }

        #bossHealthContainer.show {
            display: block;
        }

        #bossHealthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #ff00ff, #8800ff);
            transition: width 0.3s;
        }

        #bossLabel {
            display: none;
            position: absolute;
            top: 75px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff00ff;
            font-size: 14px;
            text-shadow: 0 0 10px #ff00ff;
            z-index: 100;
        }

        #bossLabel.show {
            display: block;
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #00ff00;
            font-size: 12px;
            text-align: right;
            text-shadow: 0 0 10px #00ff00;
        }

        /* Glowing stars background */
        .star {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, #ffffff 0%, rgba(255, 255, 255, 0) 70%);
            pointer-events: none;
            z-index: 0;
        }

        @keyframes starGlow {
            0%, 100% {
                opacity: 0.3;
                transform: scale(0.8);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* Mute button styles */
        #muteBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            font-size: 14px;
            background: transparent;
            color: #00ff00;
            border: 2px solid #00ff00;
            cursor: pointer;
            border-radius: 5px;
            z-index: 100;
            transition: all 0.3s;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        #muteBtn:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameInfo">
            <div id="score">Score: 0</div>
            <div id="lives">Lives: 3</div>
        </div>
        <div id="waveInfo">Wave: 1</div>
        <div id="bossHealthContainer">
            <div id="bossHealthBar"></div>
        </div>
        <div id="bossLabel">BOSS</div>
        <button id="muteBtn">üîä Sound</button>
        <div id="waveTransition">
            <div id="waveTransitionText">Wave 1 Complete!</div>
            <div id="waveTransitionSubtext">Get Ready for Wave 2</div>
        </div>
        <div id="instructions">
            <div>‚Üê ‚Üí Arrow Keys to Move</div>
            <div>SPACE to Shoot</div>
        </div>
        <div id="gameOverScreen">
            <div id="gameOverText">GAME OVER</div>
            <div id="finalScore">Final Score: 0</div>
            <button id="restartBtn">RESTART GAME</button>
        </div>
    </div>

    <script>
        const gameContainer = document.getElementById('gameContainer');
        let gameOverScreen = document.getElementById('gameOverScreen');
        let restartBtn = document.getElementById('restartBtn');
        let scoreDisplay = document.getElementById('score');
        let livesDisplay = document.getElementById('lives');
        let finalScoreDisplay = document.getElementById('finalScore');
        let muteBtn = document.getElementById('muteBtn');
        let waveInfoDisplay = document.getElementById('waveInfo');
        let waveTransition = document.getElementById('waveTransition');
        let waveTransitionText = document.getElementById('waveTransitionText');
        let waveTransitionSubtext = document.getElementById('waveTransitionSubtext');
        let bossHealthContainer = document.getElementById('bossHealthContainer');
        let bossHealthBar = document.getElementById('bossHealthBar');
        let bossLabel = document.getElementById('bossLabel');

        // Audio context and sound management
        let audioContext = null;
        let isMuted = false;
        let bgMusicOscillator = null;
        let bgMusicGain = null;
        let bgMusicTimeoutId = null;

        // Initialize audio context (must be triggered by user interaction)
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                startBackgroundMusic();
            }
        }

        // Play shooting sound effect
        function playShootSound() {
            if (!audioContext || isMuted) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Play collision sound effect
        function playCollisionSound() {
            if (!audioContext || isMuted) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // Start background music
        function startBackgroundMusic() {
            if (!audioContext || isMuted) return;
            
            // Create a simple looping bass line for background music
            bgMusicGain = audioContext.createGain();
            bgMusicGain.connect(audioContext.destination);
            bgMusicGain.gain.value = 0.05;
            
            playBackgroundNote();
        }

        // Play a repeating background note pattern
        function playBackgroundNote() {
            // Clear any existing timeout to prevent multiple chains
            if (bgMusicTimeoutId) {
                clearTimeout(bgMusicTimeoutId);
                bgMusicTimeoutId = null;
            }
            
            if (!audioContext || isMuted || gameState.gameOver) return;
            
            const notes = [110, 130.81, 146.83, 130.81]; // A2, C3, D3, C3
            const noteIndex = Math.floor((Date.now() / 500) % notes.length);
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.value = notes[noteIndex];
            
            gainNode.gain.setValueAtTime(0.03, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.4);
            
            bgMusicTimeoutId = setTimeout(playBackgroundNote, 500);
        }

        // Toggle mute/unmute
        function toggleMute() {
            isMuted = !isMuted;
            muteBtn.textContent = isMuted ? 'üîá Muted' : 'üîä Sound';
            
            if (!isMuted && audioContext) {
                playBackgroundNote();
            }
        }

        // Create animated stars background
        function createStars() {
            const existingStars = gameContainer.querySelectorAll('.star');
            existingStars.forEach(star => star.remove());
            
            const starCount = 50;
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                // Random size between 2 and 6 pixels
                const size = Math.random() * 4 + 2;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                
                // Random position
                star.style.left = Math.random() * GAME_WIDTH + 'px';
                star.style.top = Math.random() * GAME_HEIGHT + 'px';
                
                // Random animation duration for variety (2-5 seconds)
                const duration = Math.random() * 3 + 2;
                star.style.animation = `starGlow ${duration}s ease-in-out infinite`;
                
                // Random animation delay for staggered effect
                star.style.animationDelay = Math.random() * duration + 's';
                
                // Random base opacity for natural variation
                const baseOpacity = Math.random() * 0.5 + 0.3;
                star.style.opacity = baseOpacity;
                
                gameContainer.appendChild(star);
            }
        }

        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const PLAYER_WIDTH = 40;
        const PLAYER_HEIGHT = 40;
        const PLAYER_SPEED = 7;
        const ENEMY_WIDTH = 40;
        const ENEMY_HEIGHT = 40;
        const ENEMY_SPEED = 2;
        const ENEMY_TYPES_COUNT = 3;
        const PROJECTILE_SPEED = 8;
        const OBSTACLE_SIZE = 30;

        // Wave system constants
        const WAVE_BASE_ENEMIES = 5;
        const MAX_ENEMIES_PER_WAVE = 10;
        const SPEED_INCREASE_PER_WAVE = 0.3;
        const ENEMY_HORIZONTAL_MARGIN = 100;
        const BOSS_ATTACK_PATTERNS = 3;
        const TRIPLE_SHOT_SPACING = 30;
        const BARRAGE_SHOT_SPACING = 25;

        // Game state
        let gameState = {
            player: {
                x: GAME_WIDTH / 2 - PLAYER_WIDTH / 2,
                y: GAME_HEIGHT - 60,
                width: PLAYER_WIDTH,
                height: PLAYER_HEIGHT,
                speed: PLAYER_SPEED
            },
            enemies: [],
            projectiles: [],
            enemyProjectiles: [],
            obstacles: [],
            score: 0,
            lives: 3,
            gameOver: false,
            enemyDirection: 1,
            currentWave: 1,
            maxWaves: 5,
            inWaveTransition: false,
            boss: null,
            bossPhase: false
        };

        // Keyboard input
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            initAudio(); // Initialize audio on first user interaction
            if (e.key === ' ') {
                e.preventDefault();
                shootProjectile();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Initialize game
        function initGame() {
            gameState = {
                player: {
                    x: GAME_WIDTH / 2 - PLAYER_WIDTH / 2,
                    y: GAME_HEIGHT - 60,
                    width: PLAYER_WIDTH,
                    height: PLAYER_HEIGHT,
                    speed: PLAYER_SPEED
                },
                enemies: [],
                projectiles: [],
                enemyProjectiles: [],
                obstacles: [],
                score: 0,
                lives: 3,
                gameOver: false,
                enemyDirection: 1,
                currentWave: 1,
                maxWaves: 5,
                inWaveTransition: false,
                boss: null,
                bossPhase: false
            };

            gameOverScreen.classList.remove('show');
            gameContainer.innerHTML = `
                <div id="gameInfo">
                    <div id="score">Score: 0</div>
                    <div id="lives">Lives: 3</div>
                </div>
                <div id="waveInfo">Wave: 1</div>
                <div id="bossHealthContainer">
                    <div id="bossHealthBar"></div>
                </div>
                <div id="bossLabel">BOSS</div>
                <button id="muteBtn">${isMuted ? 'üîá Muted' : 'üîä Sound'}</button>
                <div id="waveTransition">
                    <div id="waveTransitionText">Wave 1 Complete!</div>
                    <div id="waveTransitionSubtext">Get Ready for Wave 2</div>
                </div>
                <div id="instructions">
                    <div>‚Üê ‚Üí Arrow Keys to Move</div>
                    <div>SPACE to Shoot</div>
                </div>
                <div id="gameOverScreen">
                    <div id="gameOverText">GAME OVER</div>
                    <div id="finalScore">Final Score: 0</div>
                    <button id="restartBtn">RESTART GAME</button>
                </div>
            `;

            scoreDisplay = document.getElementById('score');
            livesDisplay = document.getElementById('lives');
            finalScoreDisplay = document.getElementById('finalScore');
            gameOverScreen = document.getElementById('gameOverScreen');
            restartBtn = document.getElementById('restartBtn');
            muteBtn = document.getElementById('muteBtn');
            waveInfoDisplay = document.getElementById('waveInfo');
            waveTransition = document.getElementById('waveTransition');
            waveTransitionText = document.getElementById('waveTransitionText');
            waveTransitionSubtext = document.getElementById('waveTransitionSubtext');
            bossHealthContainer = document.getElementById('bossHealthContainer');
            bossHealthBar = document.getElementById('bossHealthBar');
            bossLabel = document.getElementById('bossLabel');
            restartBtn.addEventListener('click', initGame);
            muteBtn.addEventListener('click', () => {
                initAudio();
                toggleMute();
            });

            createStars();
            createEnemies();
            createObstacles();
            
            // Restart background music if audio is initialized and not muted
            if (audioContext && !isMuted) {
                playBackgroundNote();
            }
            
            gameLoop();
        }

        function createEnemies() {
            const wave = gameState.currentWave;
            // Increase enemy count with each wave (base + wave number)
            const enemyCount = Math.min(WAVE_BASE_ENEMIES + wave, MAX_ENEMIES_PER_WAVE);
            // Increase speed with each wave
            const speedMultiplier = 1 + (wave - 1) * SPEED_INCREASE_PER_WAVE;
            
            // Calculate spacing based on enemy count
            const spacing = (GAME_WIDTH - ENEMY_HORIZONTAL_MARGIN) / enemyCount;
            
            for (let i = 0; i < enemyCount; i++) {
                gameState.enemies.push({
                    x: 50 + i * spacing,
                    y: 40,
                    width: ENEMY_WIDTH,
                    height: ENEMY_HEIGHT,
                    speed: ENEMY_SPEED * speedMultiplier
                });
            }
        }

        function createObstacles() {
            const obstacleRow = GAME_HEIGHT / 2 - 15;
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    gameState.obstacles.push({
                        x: 100 + i * 180 + j * 35,
                        y: obstacleRow + j * 35,
                        width: OBSTACLE_SIZE,
                        height: OBSTACLE_SIZE,
                        health: 3
                    });
                }
            }
        }

        function createBoss() {
            gameState.boss = {
                x: GAME_WIDTH / 2 - 60,
                y: 60,
                width: 120,
                height: 80,
                speed: 3,
                maxHealth: 50,
                health: 50,
                direction: 1,
                shootCooldown: 0,
                attackPattern: 0
            };
            gameState.bossPhase = true;
            bossHealthContainer.classList.add('show');
            bossLabel.classList.add('show');
        }

        function startWaveTransition() {
            gameState.inWaveTransition = true;
            
            if (gameState.currentWave >= gameState.maxWaves) {
                // Transition to boss phase
                waveTransitionText.textContent = 'All Waves Complete!';
                waveTransitionSubtext.textContent = 'BOSS INCOMING!';
            } else {
                waveTransitionText.textContent = `Wave ${gameState.currentWave} Complete!`;
                waveTransitionSubtext.textContent = `Get Ready for Wave ${gameState.currentWave + 1}`;
            }
            
            waveTransition.classList.add('show');
            
            setTimeout(() => {
                waveTransition.classList.remove('show');
                gameState.inWaveTransition = false;
                
                if (gameState.currentWave >= gameState.maxWaves) {
                    // Start boss phase
                    createBoss();
                    waveInfoDisplay.textContent = 'BOSS BATTLE!';
                } else {
                    // Start next wave
                    gameState.currentWave++;
                    waveInfoDisplay.textContent = `Wave: ${gameState.currentWave}`;
                    createEnemies();
                }
            }, 2000);
        }

        function updateBoss() {
            if (!gameState.boss) return;
            
            const boss = gameState.boss;
            
            // Move boss left and right
            boss.x += boss.speed * boss.direction;
            
            if (boss.x <= 50 || boss.x + boss.width >= GAME_WIDTH - 50) {
                boss.direction *= -1;
            }
            
            // Boss shooting with cooldown
            boss.shootCooldown--;
            if (boss.shootCooldown <= 0) {
                // Choose attack pattern
                boss.attackPattern = (boss.attackPattern + 1) % BOSS_ATTACK_PATTERNS;
                
                if (boss.attackPattern === 0) {
                    // Single shot aimed at player
                    gameState.enemyProjectiles.push({
                        x: boss.x + boss.width / 2 - 4,
                        y: boss.y + boss.height,
                        width: 8,
                        height: 20,
                        speed: 5
                    });
                    boss.shootCooldown = 60;
                } else if (boss.attackPattern === 1) {
                    // Triple shot spread
                    for (let i = -1; i <= 1; i++) {
                        gameState.enemyProjectiles.push({
                            x: boss.x + boss.width / 2 - 4 + i * TRIPLE_SHOT_SPACING,
                            y: boss.y + boss.height,
                            width: 8,
                            height: 20,
                            speed: 4
                        });
                    }
                    boss.shootCooldown = 90;
                } else {
                    // Five shot barrage
                    for (let i = -2; i <= 2; i++) {
                        gameState.enemyProjectiles.push({
                            x: boss.x + boss.width / 2 - 4 + i * BARRAGE_SHOT_SPACING,
                            y: boss.y + boss.height,
                            width: 8,
                            height: 20,
                            speed: 3
                        });
                    }
                    boss.shootCooldown = 120;
                }
            }
            
            // Update boss health bar
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            bossHealthBar.style.width = healthPercent + '%';
        }

        function updateEnemyProjectiles() {
            gameState.enemyProjectiles = gameState.enemyProjectiles.filter(proj => {
                proj.y += proj.speed;
                return proj.y < GAME_HEIGHT;
            });
            
            // Check collision with player
            for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
                if (isColliding(gameState.enemyProjectiles[i], gameState.player)) {
                    gameState.enemyProjectiles.splice(i, 1);
                    gameState.lives--;
                    playCollisionSound();
                    
                    if (gameState.lives <= 0) {
                        gameState.gameOver = true;
                    }
                }
            }
            
            // Check collision with obstacles
            for (let i = gameState.enemyProjectiles.length - 1; i >= 0; i--) {
                for (let j = gameState.obstacles.length - 1; j >= 0; j--) {
                    if (isColliding(gameState.enemyProjectiles[i], gameState.obstacles[j])) {
                        gameState.enemyProjectiles.splice(i, 1);
                        gameState.obstacles[j].health--;
                        if (gameState.obstacles[j].health <= 0) {
                            gameState.obstacles.splice(j, 1);
                        }
                        break;
                    }
                }
            }
        }

        function shootProjectile() {
            if (!gameState.gameOver) {
                playShootSound();
                gameState.projectiles.push({
                    x: gameState.player.x + gameState.player.width / 2 - 2.5,
                    y: gameState.player.y,
                    width: 5,
                    height: 15,
                    speed: PROJECTILE_SPEED
                });
            }
        }

        function updatePlayer() {
            if (keys['ArrowLeft'] && gameState.player.x > 0) {
                gameState.player.x -= gameState.player.speed;
            }
            if (keys['ArrowRight'] && gameState.player.x < GAME_WIDTH - gameState.player.width) {
                gameState.player.x += gameState.player.speed;
            }
        }

        function updateEnemies() {
            let changeDirection = false;

            for (let enemy of gameState.enemies) {
                enemy.x += enemy.speed * gameState.enemyDirection;

                if (enemy.x <= 0 || enemy.x + enemy.width >= GAME_WIDTH) {
                    changeDirection = true;
                }
            }

            if (changeDirection) {
                gameState.enemyDirection *= -1;
                for (let enemy of gameState.enemies) {
                    enemy.y += 30;
                }
            }

            // Check if enemies reached bottom
            for (let enemy of gameState.enemies) {
                if (enemy.y > GAME_HEIGHT) {
                    gameState.gameOver = true;
                }
            }
        }

        function updateProjectiles() {
            gameState.projectiles = gameState.projectiles.filter(proj => {
                proj.y -= proj.speed;
                return proj.y > 0;
            });
        }

        function checkCollisions() {
            // Check projectile vs enemies
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    if (isColliding(gameState.projectiles[i], gameState.enemies[j])) {
                        gameState.projectiles.splice(i, 1);
                        gameState.enemies.splice(j, 1);
                        gameState.score += 100;
                        playCollisionSound();
                        break;
                    }
                }
            }

            // Check projectile vs obstacles
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                for (let j = gameState.obstacles.length - 1; j >= 0; j--) {
                    if (isColliding(gameState.projectiles[i], gameState.obstacles[j])) {
                        gameState.projectiles.splice(i, 1);
                        gameState.obstacles[j].health--;
                        playCollisionSound();
                        if (gameState.obstacles[j].health <= 0) {
                            gameState.obstacles.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            // Check projectile vs boss
            if (gameState.boss) {
                for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                    if (isColliding(gameState.projectiles[i], gameState.boss)) {
                        gameState.projectiles.splice(i, 1);
                        gameState.boss.health--;
                        gameState.score += 10;
                        playCollisionSound();
                        
                        if (gameState.boss.health <= 0) {
                            gameState.score += 1000; // Bonus for defeating boss
                            gameState.boss = null;
                            gameState.bossPhase = false;
                            gameState.enemyProjectiles = [];
                            bossHealthContainer.classList.remove('show');
                            bossLabel.classList.remove('show');
                            gameState.gameOver = true;
                            document.getElementById('gameOverText').textContent = 'YOU WIN!';
                        }
                        break;
                    }
                }
            }

            // Check if all enemies destroyed (wave complete)
            if (gameState.enemies.length === 0 && !gameState.inWaveTransition && !gameState.bossPhase) {
                startWaveTransition();
            }
        }

        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function updateUI() {
            scoreDisplay.textContent = `Score: ${gameState.score}`;
            livesDisplay.textContent = `Lives: ${gameState.lives}`;
        }

        function render() {
            // Clear game container
            const existingElements = gameContainer.querySelectorAll('.player, .enemy, .projectile, .obstacle, .boss, .boss-projectile');
            existingElements.forEach(el => el.remove());

            // Render player
            const playerEl = document.createElement('div');
            playerEl.className = 'player';
            playerEl.style.left = gameState.player.x + 'px';
            playerEl.style.top = gameState.player.y + 'px';
            gameContainer.appendChild(playerEl);

            // Render enemies
            for (let enemy of gameState.enemies) {
                const enemyEl = document.createElement('div');
                enemyEl.className = `enemy enemy-type-${enemy.type || 1}`;
                enemyEl.style.left = enemy.x + 'px';
                enemyEl.style.top = enemy.y + 'px';
                gameContainer.appendChild(enemyEl);
            }

            // Render projectiles
            for (let projectile of gameState.projectiles) {
                const projEl = document.createElement('div');
                projEl.className = 'projectile';
                projEl.style.left = projectile.x + 'px';
                projEl.style.top = projectile.y + 'px';
                gameContainer.appendChild(projEl);
            }

            // Render obstacles
            for (let obstacle of gameState.obstacles) {
                const obstacleEl = document.createElement('div');
                obstacleEl.className = 'obstacle';
                obstacleEl.style.left = obstacle.x + 'px';
                obstacleEl.style.top = obstacle.y + 'px';
                gameContainer.appendChild(obstacleEl);
            }

            // Render boss
            if (gameState.boss) {
                const bossEl = document.createElement('div');
                bossEl.className = 'boss';
                bossEl.style.left = gameState.boss.x + 'px';
                bossEl.style.top = gameState.boss.y + 'px';
                gameContainer.appendChild(bossEl);
            }

            // Render enemy projectiles
            for (let projectile of gameState.enemyProjectiles) {
                const projEl = document.createElement('div');
                projEl.className = 'boss-projectile';
                projEl.style.left = projectile.x + 'px';
                projEl.style.top = projectile.y + 'px';
                gameContainer.appendChild(projEl);
            }
        }

        function gameLoop() {
            if (gameState.gameOver) {
                finalScoreDisplay.textContent = `Final Score: ${gameState.score}`;
                gameOverScreen.classList.add('show');
                return;
            }

            if (gameState.inWaveTransition) {
                requestAnimationFrame(gameLoop);
                return;
            }

            updatePlayer();
            updateEnemies();
            updateProjectiles();
            updateBoss();
            updateEnemyProjectiles();
            checkCollisions();
            updateUI();
            render();

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        initGame();
    </script>
</body>
</html>